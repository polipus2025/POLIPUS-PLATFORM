import type { Express } from "express";
import { createServer, type Server } from "http";
import { storage } from "./storage";
import bcrypt from "bcryptjs";
import jwt from "jsonwebtoken";
import crypto from "crypto";
import { 
  insertCommoditySchema, 
  insertInspectionSchema, 
  insertCertificationSchema,
  insertAlertSchema,
  insertReportSchema,
  insertFarmerSchema,
  insertFarmPlotSchema,
  insertCropPlanSchema,
  insertHarvestRecordSchema,
  insertInputDistributionSchema,

  insertLraIntegrationSchema,
  insertMoaIntegrationSchema,
  insertCustomsIntegrationSchema,
  insertGovernmentSyncLogSchema,
  insertAnalyticsDataSchema,
  insertAuditLogSchema,
  insertSystemAuditSchema,
  insertAuditReportSchema,
  insertFarmGpsMappingSchema,
  insertDeforestationMonitoringSchema,
  insertEudrComplianceSchema,
  insertGeofencingZoneSchema,
  insertInternationalStandardSchema,
  insertCommodityStandardsComplianceSchema,
  insertStandardsApiIntegrationSchema,
  insertStandardsSyncLogSchema,
  insertAuthUserSchema
} from "@shared/schema";
import { z } from "zod";

// JWT Secret - in production, this should be in environment variables
const JWT_SECRET = process.env.JWT_SECRET || "agritrace360-dev-secret-key";

// Middleware to verify JWT tokens
const authenticateToken = (req: any, res: any, next: any) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (token == null) {
    return res.status(401).json({ message: 'Access token required' });
  }

  jwt.verify(token, JWT_SECRET, (err: any, user: any) => {
    if (err) {
      return res.status(403).json({ message: 'Invalid or expired token' });
    }
    req.user = user;
    next();
  });
};

export async function registerRoutes(app: Express): Promise<Server> {
  
  // Authentication routes
  app.post("/api/auth/regulatory-login", async (req, res) => {
    try {
      const { username, password, role, department, userType } = req.body;
      
      // Validate input
      if (!username || !password || !role) {
        return res.status(400).json({ 
          success: false, 
          message: "Username, password, and role are required" 
        });
      }

      // Check if user exists
      const user = await storage.getUserByUsername(username);
      if (!user) {
        return res.status(401).json({ 
          success: false, 
          message: "Invalid credentials" 
        });
      }

      // Verify password
      const isValidPassword = await bcrypt.compare(password, user.passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ 
          success: false, 
          message: "Invalid credentials" 
        });
      }

      // Verify role permissions
      if (user.role !== role || (role !== 'regulatory_admin' && role !== 'regulatory_staff')) {
        return res.status(403).json({ 
          success: false, 
          message: "Access denied for this role" 
        });
      }

      // Generate JWT token
      const token = jwt.sign(
        { 
          userId: user.id, 
          username: user.username, 
          role: user.role,
          userType: 'regulatory'
        },
        JWT_SECRET,
        { expiresIn: '24h' }
      );

      // Update last login
      await storage.updateUserLastLogin(user.id);

      res.json({
        success: true,
        token,
        user: {
          id: user.id,
          username: user.username,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
          department: user.department
        }
      });

    } catch (error) {
      console.error('Regulatory login error:', error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.post("/api/auth/farmer-login", async (req, res) => {
    try {
      const { farmerId, password, county, phoneNumber, userType } = req.body;
      
      // Validate input
      if (!farmerId || !password) {
        return res.status(400).json({ 
          success: false, 
          message: "Farmer ID and password are required" 
        });
      }

      // Check if user exists - farmers use farmerId as username
      const user = await storage.getUserByUsername(farmerId);
      if (!user || user.role !== 'farmer') {
        return res.status(401).json({ 
          success: false, 
          message: "Invalid farmer credentials" 
        });
      }

      // Verify password
      const isValidPassword = await bcrypt.compare(password, user.passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ 
          success: false, 
          message: "Invalid farmer credentials" 
        });
      }

      // Generate JWT token
      const token = jwt.sign(
        { 
          userId: user.id, 
          farmerId: user.farmerId, 
          role: user.role,
          userType: 'farmer'
        },
        JWT_SECRET,
        { expiresIn: '24h' }
      );

      // Update last login
      await storage.updateUserLastLogin(user.id);

      res.json({
        success: true,
        token,
        user: {
          id: user.id,
          farmerId: user.farmerId,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
          jurisdiction: user.jurisdiction
        }
      });

    } catch (error) {
      console.error('Farmer login error:', error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.post("/api/auth/field-agent-login", async (req, res) => {
    try {
      const { agentId, password, jurisdiction, phoneNumber, userType } = req.body;
      
      // Validate input
      if (!agentId || !password) {
        return res.status(400).json({ 
          success: false, 
          message: "Agent ID and password are required" 
        });
      }

      // Check if user exists - field agents use agentId as username
      const user = await storage.getUserByUsername(agentId);
      if (!user || user.role !== 'field_agent') {
        return res.status(401).json({ 
          success: false, 
          message: "Invalid field agent credentials" 
        });
      }

      // Verify password
      const isValidPassword = await bcrypt.compare(password, user.passwordHash);
      if (!isValidPassword) {
        return res.status(401).json({ 
          success: false, 
          message: "Invalid field agent credentials" 
        });
      }

      // Generate JWT token
      const token = jwt.sign(
        { 
          userId: user.id, 
          agentId: agentId, 
          role: user.role,
          userType: 'field_agent',
          jurisdiction: user.jurisdiction
        },
        JWT_SECRET,
        { expiresIn: '24h' }
      );

      // Update last login
      await storage.updateUserLastLogin(user.id);

      res.json({
        success: true,
        token,
        user: {
          id: user.id,
          username: user.username,
          firstName: user.firstName,
          lastName: user.lastName,
          role: user.role,
          jurisdiction: user.jurisdiction
        }
      });

    } catch (error) {
      console.error('Field agent login error:', error);
      res.status(500).json({ 
        success: false, 
        message: "Internal server error" 
      });
    }
  });

  app.post("/api/auth/register", authenticateToken, async (req, res) => {
    try {
      // Only regulatory admins can register new users
      if (req.user.role !== 'regulatory_admin') {
        return res.status(403).json({ 
          success: false, 
          message: "Only administrators can register new users" 
        });
      }

      const validatedData = insertAuthUserSchema.parse(req.body);
      
      // Hash password
      const passwordHash = await bcrypt.hash(validatedData.passwordHash, 12);
      
      const userData = {
        ...validatedData,
        passwordHash
      };

      const user = await storage.createAuthUser(userData);
      res.status(201).json({ success: true, user });
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ 
          success: false, 
          message: "Validation error", 
          errors: error.errors 
        });
      } else {
        console.error('User registration error:', error);
        res.status(500).json({ 
          success: false, 
          message: "Failed to register user" 
        });
      }
    }
  });

  // Dashboard routes
  app.get("/api/dashboard/metrics", async (req, res) => {
    try {
      const metrics = await storage.getDashboardMetrics();
      res.json(metrics);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch dashboard metrics" });
    }
  });

  app.get("/api/dashboard/compliance-by-county", async (req, res) => {
    try {
      const data = await storage.getComplianceDataByCounty();
      res.json(data);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch compliance data by county" });
    }
  });

  // Commodity routes
  app.get("/api/commodities", async (req, res) => {
    try {
      const { county, type } = req.query;
      let commodities;
      
      if (county) {
        commodities = await storage.getCommoditiesByCounty(county as string);
      } else if (type) {
        commodities = await storage.getCommoditiesByType(type as string);
      } else {
        commodities = await storage.getCommodities();
      }
      
      res.json(commodities);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch commodities" });
    }
  });

  app.get("/api/commodities/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const commodity = await storage.getCommodity(id);
      
      if (!commodity) {
        return res.status(404).json({ message: "Commodity not found" });
      }
      
      res.json(commodity);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch commodity" });
    }
  });

  app.post("/api/commodities", async (req, res) => {
    try {
      const validatedData = insertCommoditySchema.parse(req.body);
      const commodity = await storage.createCommodity(validatedData);
      res.status(201).json(commodity);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create commodity" });
    }
  });

  app.put("/api/commodities/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const commodity = await storage.updateCommodity(id, updates);
      
      if (!commodity) {
        return res.status(404).json({ message: "Commodity not found" });
      }
      
      res.json(commodity);
    } catch (error) {
      res.status(500).json({ message: "Failed to update commodity" });
    }
  });

  app.delete("/api/commodities/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.deleteCommodity(id);
      
      if (!success) {
        return res.status(404).json({ message: "Commodity not found" });
      }
      
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ message: "Failed to delete commodity" });
    }
  });

  // Inspection routes
  app.get("/api/inspections", async (req, res) => {
    try {
      const { commodityId, inspectorId } = req.query;
      let inspections;
      
      if (commodityId) {
        inspections = await storage.getInspectionsByCommodity(parseInt(commodityId as string));
      } else if (inspectorId) {
        inspections = await storage.getInspectionsByInspector(inspectorId as string);
      } else {
        inspections = await storage.getInspections();
      }
      
      res.json(inspections);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch inspections" });
    }
  });

  app.get("/api/inspections/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const inspection = await storage.getInspection(id);
      
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }
      
      res.json(inspection);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch inspection" });
    }
  });

  app.post("/api/inspections", async (req, res) => {
    try {
      const validatedData = insertInspectionSchema.parse(req.body);
      const inspection = await storage.createInspection(validatedData);
      res.status(201).json(inspection);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create inspection" });
    }
  });

  app.put("/api/inspections/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const inspection = await storage.updateInspection(id, updates);
      
      if (!inspection) {
        return res.status(404).json({ message: "Inspection not found" });
      }
      
      res.json(inspection);
    } catch (error) {
      res.status(500).json({ message: "Failed to update inspection" });
    }
  });

  // Certification routes
  app.get("/api/certifications", async (req, res) => {
    try {
      const { commodityId } = req.query;
      let certifications;
      
      if (commodityId) {
        certifications = await storage.getCertificationsByCommodity(parseInt(commodityId as string));
      } else {
        certifications = await storage.getCertifications();
      }
      
      res.json(certifications);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch certifications" });
    }
  });

  app.get("/api/certifications/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const certification = await storage.getCertification(id);
      
      if (!certification) {
        return res.status(404).json({ message: "Certification not found" });
      }
      
      res.json(certification);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch certification" });
    }
  });

  app.post("/api/certifications", async (req, res) => {
    try {
      const validatedData = insertCertificationSchema.parse(req.body);
      const certification = await storage.createCertification(validatedData);
      res.status(201).json(certification);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create certification" });
    }
  });

  app.put("/api/certifications/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const updates = req.body;
      const certification = await storage.updateCertification(id, updates);
      
      if (!certification) {
        return res.status(404).json({ message: "Certification not found" });
      }
      
      res.json(certification);
    } catch (error) {
      res.status(500).json({ message: "Failed to update certification" });
    }
  });

  // Alert routes
  app.get("/api/alerts", async (req, res) => {
    try {
      const { unreadOnly } = req.query;
      let alerts;
      
      if (unreadOnly === 'true') {
        alerts = await storage.getUnreadAlerts();
      } else {
        alerts = await storage.getAlerts();
      }
      
      res.json(alerts);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch alerts" });
    }
  });

  app.post("/api/alerts", async (req, res) => {
    try {
      const validatedData = insertAlertSchema.parse(req.body);
      const alert = await storage.createAlert(validatedData);
      res.status(201).json(alert);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create alert" });
    }
  });

  app.put("/api/alerts/:id/read", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const success = await storage.markAlertAsRead(id);
      
      if (!success) {
        return res.status(404).json({ message: "Alert not found" });
      }
      
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ message: "Failed to mark alert as read" });
    }
  });

  // Report routes
  app.get("/api/reports", async (req, res) => {
    try {
      const reports = await storage.getReports();
      res.json(reports);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch reports" });
    }
  });

  app.post("/api/reports", async (req, res) => {
    try {
      const validatedData = insertReportSchema.parse(req.body);
      const report = await storage.createReport(validatedData);
      res.status(201).json(report);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create report" });
    }
  });

  // Farm Management Platform Routes
  
  // Farmer routes
  app.get("/api/farmers", async (req, res) => {
    try {
      const { county } = req.query;
      let farmers;
      
      if (county) {
        farmers = await storage.getFarmersByCounty(county as string);
      } else {
        farmers = await storage.getFarmers();
      }
      
      res.json(farmers);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch farmers" });
    }
  });

  app.get("/api/farmers/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const farmer = await storage.getFarmer(id);
      
      if (!farmer) {
        return res.status(404).json({ message: "Farmer not found" });
      }
      
      res.json(farmer);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch farmer" });
    }
  });

  app.post("/api/farmers", async (req, res) => {
    try {
      const validatedData = insertFarmerSchema.parse(req.body);
      const farmer = await storage.createFarmer(validatedData);
      res.status(201).json(farmer);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create farmer" });
    }
  });

  // Farm Plot routes
  app.get("/api/farm-plots", async (req, res) => {
    try {
      const { farmerId } = req.query;
      let farmPlots;
      
      if (farmerId) {
        farmPlots = await storage.getFarmPlotsByFarmer(parseInt(farmerId as string));
      } else {
        farmPlots = await storage.getFarmPlots();
      }
      
      res.json(farmPlots);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch farm plots" });
    }
  });

  app.post("/api/farm-plots", async (req, res) => {
    try {
      const validatedData = insertFarmPlotSchema.parse(req.body);
      const farmPlot = await storage.createFarmPlot(validatedData);
      res.status(201).json(farmPlot);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create farm plot" });
    }
  });

  // Crop Plan routes
  app.get("/api/crop-plans", async (req, res) => {
    try {
      const { farmerId, year, season } = req.query;
      let cropPlans;
      
      if (farmerId) {
        cropPlans = await storage.getCropPlansByFarmer(parseInt(farmerId as string));
      } else if (year && season) {
        cropPlans = await storage.getCropPlansBySeason(parseInt(year as string), season as string);
      } else {
        cropPlans = await storage.getCropPlans();
      }
      
      res.json(cropPlans);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch crop plans" });
    }
  });

  app.post("/api/crop-plans", async (req, res) => {
    try {
      const validatedData = insertCropPlanSchema.parse(req.body);
      const cropPlan = await storage.createCropPlan(validatedData);
      res.status(201).json(cropPlan);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create crop plan" });
    }
  });

  // Input Distribution routes
  app.get("/api/input-distributions", async (req, res) => {
    try {
      const { farmerId, inputType } = req.query;
      let inputDistributions;
      
      if (farmerId) {
        inputDistributions = await storage.getInputDistributionsByFarmer(parseInt(farmerId as string));
      } else if (inputType) {
        inputDistributions = await storage.getInputDistributionsByType(inputType as string);
      } else {
        inputDistributions = await storage.getInputDistributions();
      }
      
      res.json(inputDistributions);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch input distributions" });
    }
  });

  app.post("/api/input-distributions", async (req, res) => {
    try {
      const validatedData = insertInputDistributionSchema.parse(req.body);
      const inputDistribution = await storage.createInputDistribution(validatedData);
      res.status(201).json(inputDistribution);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create input distribution" });
    }
  });



  // Government Integration Routes
  
  // LRA Integration routes
  app.get("/api/lra-integrations", async (req, res) => {
    try {
      const { status } = req.query;
      let integrations;
      
      if (status) {
        integrations = await storage.getLraIntegrationsByStatus(status as string);
      } else {
        integrations = await storage.getLraIntegrations();
      }
      
      res.json(integrations);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch LRA integrations" });
    }
  });

  app.post("/api/lra-integrations", async (req, res) => {
    try {
      const validatedData = insertLraIntegrationSchema.parse(req.body);
      const integration = await storage.createLraIntegration(validatedData);
      res.status(201).json(integration);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create LRA integration" });
    }
  });

  // MOA Integration routes
  app.get("/api/moa-integrations", async (req, res) => {
    try {
      const { status } = req.query;
      let integrations;
      
      if (status) {
        integrations = await storage.getMoaIntegrationsByStatus(status as string);
      } else {
        integrations = await storage.getMoaIntegrations();
      }
      
      res.json(integrations);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch MOA integrations" });
    }
  });

  app.post("/api/moa-integrations", async (req, res) => {
    try {
      const validatedData = insertMoaIntegrationSchema.parse(req.body);
      const integration = await storage.createMoaIntegration(validatedData);
      res.status(201).json(integration);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create MOA integration" });
    }
  });

  // Customs Integration routes
  app.get("/api/customs-integrations", async (req, res) => {
    try {
      const { status } = req.query;
      let integrations;
      
      if (status) {
        integrations = await storage.getCustomsIntegrationsByStatus(status as string);
      } else {
        integrations = await storage.getCustomsIntegrations();
      }
      
      res.json(integrations);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch Customs integrations" });
    }
  });

  app.post("/api/customs-integrations", async (req, res) => {
    try {
      const validatedData = insertCustomsIntegrationSchema.parse(req.body);
      const integration = await storage.createCustomsIntegration(validatedData);
      res.status(201).json(integration);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create Customs integration" });
    }
  });

  // Government Sync Log routes
  app.get("/api/government-sync-logs", async (req, res) => {
    try {
      const { syncType, entityId } = req.query;
      let logs;
      
      if (syncType && entityId) {
        logs = await storage.getGovernmentSyncLogsByEntity(parseInt(entityId as string), syncType as string);
      } else if (syncType) {
        logs = await storage.getGovernmentSyncLogsByType(syncType as string);
      } else {
        logs = await storage.getGovernmentSyncLogs();
      }
      
      res.json(logs);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch government sync logs" });
    }
  });

  // Government Synchronization endpoints
  app.post("/api/sync/lra/:commodityId", async (req, res) => {
    try {
      const commodityId = parseInt(req.params.commodityId);
      const result = await storage.syncWithLRA(commodityId);
      
      if (result.success) {
        res.json(result);
      } else {
        res.status(400).json(result);
      }
    } catch (error) {
      res.status(500).json({ success: false, message: "Failed to sync with LRA" });
    }
  });

  app.post("/api/sync/moa/:commodityId", async (req, res) => {
    try {
      const commodityId = parseInt(req.params.commodityId);
      const result = await storage.syncWithMOA(commodityId);
      
      if (result.success) {
        res.json(result);
      } else {
        res.status(400).json(result);
      }
    } catch (error) {
      res.status(500).json({ success: false, message: "Failed to sync with MOA" });
    }
  });

  app.post("/api/sync/customs/:commodityId", async (req, res) => {
    try {
      const commodityId = parseInt(req.params.commodityId);
      const result = await storage.syncWithCustoms(commodityId);
      
      if (result.success) {
        res.json(result);
      } else {
        res.status(400).json(result);
      }
    } catch (error) {
      res.status(500).json({ success: false, message: "Failed to sync with Customs" });
    }
  });

  // Government Compliance Status endpoint
  app.get("/api/government-compliance/:commodityId", async (req, res) => {
    try {
      const commodityId = parseInt(req.params.commodityId);
      const status = await storage.getGovernmentComplianceStatus(commodityId);
      res.json(status);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch government compliance status" });
    }
  });

  // Analytics routes (AgriTrace360™ Admin only)
  app.get("/api/analytics", async (req, res) => {
    try {
      const { dataType, timeframe } = req.query;
      const data = await storage.getAnalyticsData(
        dataType as string,
        timeframe as string
      );
      res.json(data);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch analytics data" });
    }
  });

  app.post("/api/analytics", async (req, res) => {
    try {
      const validatedData = insertAnalyticsDataSchema.parse(req.body);
      const analytics = await storage.createAnalyticsData(validatedData);
      res.status(201).json(analytics);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid analytics data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create analytics data" });
    }
  });

  app.get("/api/analytics/compliance-trends", async (req, res) => {
    try {
      const { timeframe = "monthly" } = req.query;
      const trends = await storage.generateComplianceTrends(timeframe as string);
      res.json(trends);
    } catch (error) {
      res.status(500).json({ message: "Failed to generate compliance trends" });
    }
  });

  app.get("/api/analytics/farm-performance", async (req, res) => {
    try {
      const { farmerId } = req.query;
      const performance = await storage.generateFarmPerformanceAnalytics(
        farmerId ? parseInt(farmerId as string) : undefined
      );
      res.json(performance);
    } catch (error) {
      res.status(500).json({ message: "Failed to generate farm performance analytics" });
    }
  });

  app.get("/api/analytics/regional", async (req, res) => {
    try {
      const { county } = req.query;
      const regional = await storage.generateRegionalAnalytics(county as string);
      res.json(regional);
    } catch (error) {
      res.status(500).json({ message: "Failed to generate regional analytics" });
    }
  });

  app.get("/api/analytics/system-health", async (req, res) => {
    try {
      const health = await storage.generateSystemHealthMetrics();
      res.json(health);
    } catch (error) {
      res.status(500).json({ message: "Failed to generate system health metrics" });
    }
  });

  // Audit routes (AgriTrace360™ Admin only)
  app.get("/api/audit/logs", async (req, res) => {
    try {
      const { auditType, userId, startDate, endDate } = req.query;
      const logs = await storage.getAuditLogs(
        auditType as string,
        userId as string,
        startDate ? new Date(startDate as string) : undefined,
        endDate ? new Date(endDate as string) : undefined
      );
      res.json(logs);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch audit logs" });
    }
  });

  app.post("/api/audit/logs", async (req, res) => {
    try {
      const validatedData = insertAuditLogSchema.parse(req.body);
      const log = await storage.createAuditLog(validatedData);
      res.status(201).json(log);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid audit log data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create audit log" });
    }
  });

  app.get("/api/audit/system-audits", async (req, res) => {
    try {
      const { status } = req.query;
      const audits = await storage.getSystemAudits(status as string);
      res.json(audits);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch system audits" });
    }
  });

  app.get("/api/audit/system-audits/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const audit = await storage.getSystemAudit(id);
      
      if (!audit) {
        return res.status(404).json({ message: "System audit not found" });
      }
      
      res.json(audit);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch system audit" });
    }
  });

  app.post("/api/audit/system-audits", async (req, res) => {
    try {
      const validatedData = insertSystemAuditSchema.parse(req.body);
      const audit = await storage.createSystemAudit(validatedData);
      res.status(201).json(audit);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid system audit data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create system audit" });
    }
  });

  app.patch("/api/audit/system-audits/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const audit = await storage.updateSystemAudit(id, req.body);
      
      if (!audit) {
        return res.status(404).json({ message: "System audit not found" });
      }
      
      res.json(audit);
    } catch (error) {
      res.status(500).json({ message: "Failed to update system audit" });
    }
  });

  app.get("/api/audit/reports", async (req, res) => {
    try {
      const { confidentialityLevel } = req.query;
      const reports = await storage.getAuditReports(confidentialityLevel as string);
      res.json(reports);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch audit reports" });
    }
  });

  app.get("/api/audit/reports/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const report = await storage.getAuditReport(id);
      
      if (!report) {
        return res.status(404).json({ message: "Audit report not found" });
      }
      
      res.json(report);
    } catch (error) {
      res.status(500).json({ message: "Failed to fetch audit report" });
    }
  });

  app.post("/api/audit/reports", async (req, res) => {
    try {
      const validatedData = insertAuditReportSchema.parse(req.body);
      const report = await storage.createAuditReport(validatedData);
      res.status(201).json(report);
    } catch (error) {
      if (error instanceof z.ZodError) {
        return res.status(400).json({ message: "Invalid audit report data", errors: error.errors });
      }
      res.status(500).json({ message: "Failed to create audit report" });
    }
  });

  app.patch("/api/audit/reports/:id", async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      const report = await storage.updateAuditReport(id, req.body);
      
      if (!report) {
        return res.status(404).json({ message: "Audit report not found" });
      }
      
      res.json(report);
    } catch (error) {
      res.status(500).json({ message: "Failed to update audit report" });
    }
  });

  // GPS Farm Mapping routes
  app.get('/api/farm-gps-mappings', async (req, res) => {
    try {
      const { farmerId, farmPlotId } = req.query;
      let mappings;
      
      if (farmerId) {
        mappings = await storage.getFarmGpsMappingsByFarmer(parseInt(farmerId as string));
      } else {
        mappings = await storage.getFarmGpsMappings();
      }
      
      res.json(mappings);
    } catch (error) {
      console.error('Error fetching GPS mappings:', error);
      res.status(500).json({ message: 'Failed to fetch GPS mappings' });
    }
  });

  app.get('/api/farm-gps-mappings/:id', async (req, res) => {
    try {
      const mapping = await storage.getFarmGpsMapping(parseInt(req.params.id));
      if (!mapping) {
        return res.status(404).json({ message: 'GPS mapping not found' });
      }
      res.json(mapping);
    } catch (error) {
      console.error('Error fetching GPS mapping:', error);
      res.status(500).json({ message: 'Failed to fetch GPS mapping' });
    }
  });

  app.post('/api/farm-gps-mappings', async (req, res) => {
    try {
      const validatedData = insertFarmGpsMappingSchema.parse(req.body);
      const mapping = await storage.createFarmGpsMapping(validatedData);
      res.status(201).json(mapping);
    } catch (error) {
      console.error('Error creating GPS mapping:', error);
      res.status(500).json({ message: 'Failed to create GPS mapping' });
    }
  });

  app.put('/api/farm-gps-mappings/:id', async (req, res) => {
    try {
      const updatedMapping = await storage.updateFarmGpsMapping(parseInt(req.params.id), req.body);
      if (!updatedMapping) {
        return res.status(404).json({ message: 'GPS mapping not found' });
      }
      res.json(updatedMapping);
    } catch (error) {
      console.error('Error updating GPS mapping:', error);
      res.status(500).json({ message: 'Failed to update GPS mapping' });
    }
  });

  // Deforestation Monitoring routes
  app.get('/api/deforestation-monitoring', async (req, res) => {
    try {
      const { farmGpsMappingId, riskLevel } = req.query;
      let monitorings;
      
      if (farmGpsMappingId) {
        monitorings = await storage.getDeforestationMonitoringsByMapping(parseInt(farmGpsMappingId as string));
      } else if (riskLevel) {
        monitorings = await storage.getDeforestationMonitoringsByRiskLevel(riskLevel as string);
      } else {
        monitorings = await storage.getDeforestationMonitorings();
      }
      
      res.json(monitorings);
    } catch (error) {
      console.error('Error fetching deforestation monitoring:', error);
      res.status(500).json({ message: 'Failed to fetch deforestation monitoring' });
    }
  });

  app.get('/api/deforestation-monitoring/:id', async (req, res) => {
    try {
      const monitoring = await storage.getDeforestationMonitoring(parseInt(req.params.id));
      if (!monitoring) {
        return res.status(404).json({ message: 'Deforestation monitoring not found' });
      }
      res.json(monitoring);
    } catch (error) {
      console.error('Error fetching deforestation monitoring:', error);
      res.status(500).json({ message: 'Failed to fetch deforestation monitoring' });
    }
  });

  app.post('/api/deforestation-monitoring', async (req, res) => {
    try {
      const validatedData = insertDeforestationMonitoringSchema.parse(req.body);
      const monitoring = await storage.createDeforestationMonitoring(validatedData);
      res.status(201).json(monitoring);
    } catch (error) {
      console.error('Error creating deforestation monitoring:', error);
      res.status(500).json({ message: 'Failed to create deforestation monitoring' });
    }
  });

  // EUDR Compliance routes
  app.get('/api/eudr-compliance', async (req, res) => {
    try {
      const { commodityId, farmGpsMappingId } = req.query;
      let compliances;
      
      if (commodityId) {
        compliances = await storage.getEudrComplianceByCommodity(parseInt(commodityId as string));
      } else if (farmGpsMappingId) {
        const compliance = await storage.getEudrComplianceByMapping(parseInt(farmGpsMappingId as string));
        compliances = compliance ? [compliance] : [];
      } else {
        compliances = await storage.getEudrCompliances();
      }
      
      res.json(compliances);
    } catch (error) {
      console.error('Error fetching EUDR compliance:', error);
      res.status(500).json({ message: 'Failed to fetch EUDR compliance' });
    }
  });

  app.get('/api/eudr-compliance/:id', async (req, res) => {
    try {
      const compliance = await storage.getEudrCompliance(parseInt(req.params.id));
      if (!compliance) {
        return res.status(404).json({ message: 'EUDR compliance not found' });
      }
      res.json(compliance);
    } catch (error) {
      console.error('Error fetching EUDR compliance:', error);
      res.status(500).json({ message: 'Failed to fetch EUDR compliance' });
    }
  });

  app.post('/api/eudr-compliance', async (req, res) => {
    try {
      const validatedData = insertEudrComplianceSchema.parse(req.body);
      const compliance = await storage.createEudrCompliance(validatedData);
      res.status(201).json(compliance);
    } catch (error) {
      console.error('Error creating EUDR compliance:', error);
      res.status(500).json({ message: 'Failed to create EUDR compliance' });
    }
  });

  // Geofencing Zones routes
  app.get('/api/geofencing-zones', async (req, res) => {
    try {
      const { zoneType } = req.query;
      let zones;
      
      if (zoneType) {
        zones = await storage.getGeofencingZonesByType(zoneType as string);
      } else {
        zones = await storage.getGeofencingZones();
      }
      
      res.json(zones);
    } catch (error) {
      console.error('Error fetching geofencing zones:', error);
      res.status(500).json({ message: 'Failed to fetch geofencing zones' });
    }
  });

  app.get('/api/geofencing-zones/:id', async (req, res) => {
    try {
      const zone = await storage.getGeofencingZone(parseInt(req.params.id));
      if (!zone) {
        return res.status(404).json({ message: 'Geofencing zone not found' });
      }
      res.json(zone);
    } catch (error) {
      console.error('Error fetching geofencing zone:', error);
      res.status(500).json({ message: 'Failed to fetch geofencing zone' });
    }
  });

  app.post('/api/geofencing-zones', async (req, res) => {
    try {
      const validatedData = insertGeofencingZoneSchema.parse(req.body);
      const zone = await storage.createGeofencingZone(validatedData);
      res.status(201).json(zone);
    } catch (error) {
      console.error('Error creating geofencing zone:', error);
      res.status(500).json({ message: 'Failed to create geofencing zone' });
    }
  });

  // GPS Analysis and Validation routes
  app.post('/api/gps/validate-coordinates', async (req, res) => {
    try {
      const { coordinates } = req.body;
      if (!coordinates) {
        return res.status(400).json({ message: 'Coordinates required' });
      }
      
      const validation = await storage.validateGpsCoordinates(coordinates);
      res.json(validation);
    } catch (error) {
      console.error('Error validating GPS coordinates:', error);
      res.status(500).json({ message: 'Failed to validate GPS coordinates' });
    }
  });

  app.get('/api/gps/check-eudr-compliance/:farmGpsMappingId', async (req, res) => {
    try {
      const complianceCheck = await storage.checkEudrCompliance(parseInt(req.params.farmGpsMappingId));
      res.json(complianceCheck);
    } catch (error) {
      console.error('Error checking EUDR compliance:', error);
      res.status(500).json({ message: 'Failed to check EUDR compliance' });
    }
  });

  app.get('/api/gps/detect-deforestation/:farmGpsMappingId', async (req, res) => {
    try {
      const deforestationCheck = await storage.detectDeforestation(parseInt(req.params.farmGpsMappingId));
      res.json(deforestationCheck);
    } catch (error) {
      console.error('Error detecting deforestation:', error);
      res.status(500).json({ message: 'Failed to detect deforestation' });
    }
  });

  app.get('/api/gps/traceability-report/:commodityId', async (req, res) => {
    try {
      const report = await storage.generateTraceabilityReport(parseInt(req.params.commodityId));
      res.json(report);
    } catch (error) {
      console.error('Error generating traceability report:', error);
      res.status(500).json({ message: 'Failed to generate traceability report' });
    }
  });

  // International Standards routes
  app.get('/api/international-standards', async (req, res) => {
    try {
      const { standardType, organizationName } = req.query;
      let standards;
      
      if (standardType) {
        standards = await storage.getInternationalStandardsByType(standardType as string);
      } else if (organizationName) {
        standards = await storage.getInternationalStandardsByOrganization(organizationName as string);
      } else {
        standards = await storage.getInternationalStandards();
      }
      
      res.json(standards);
    } catch (error) {
      console.error('Error fetching international standards:', error);
      res.status(500).json({ message: 'Failed to fetch international standards' });
    }
  });

  app.get('/api/international-standards/overview', async (req, res) => {
    try {
      const standards = await storage.getInternationalStandards();
      const compliance = await storage.getStandardsCompliance();
      
      const overview = {
        totalStandards: standards.length,
        standardsByType: standards.reduce((acc: any, std) => {
          acc[std.standardType] = (acc[std.standardType] || 0) + 1;
          return acc;
        }, {}),
        complianceOverview: {
          total: compliance.length,
          compliant: compliance.filter(c => c.complianceStatus === 'compliant').length,
          nonCompliant: compliance.filter(c => c.complianceStatus === 'non_compliant').length,
          pending: compliance.filter(c => c.complianceStatus === 'pending').length,
          expired: compliance.filter(c => c.complianceStatus === 'expired').length
        }
      };
      
      res.json(overview);
    } catch (error) {
      console.error('Error generating international standards overview:', error);
      res.status(500).json({ message: 'Failed to generate overview' });
    }
  });

  app.get('/api/international-standards/:id', async (req, res) => {
    try {
      const standard = await storage.getInternationalStandard(parseInt(req.params.id));
      if (!standard) {
        return res.status(404).json({ message: 'International standard not found' });
      }
      res.json(standard);
    } catch (error) {
      console.error('Error fetching international standard:', error);
      res.status(500).json({ message: 'Failed to fetch international standard' });
    }
  });

  app.post('/api/international-standards', async (req, res) => {
    try {
      const validatedData = insertInternationalStandardSchema.parse(req.body);
      const standard = await storage.createInternationalStandard(validatedData);
      res.status(201).json(standard);
    } catch (error) {
      console.error('Error creating international standard:', error);
      res.status(500).json({ message: 'Failed to create international standard' });
    }
  });

  app.post('/api/international-standards/:id/sync', async (req, res) => {
    try {
      const standardId = parseInt(req.params.id);
      
      // Simulate sync process
      const syncResult = {
        success: true,
        syncDate: new Date(),
        recordsUpdated: Math.floor(Math.random() * 100) + 1,
        message: 'Standards database synchronized successfully'
      };
      
      res.json(syncResult);
    } catch (error) {
      console.error('Error syncing with standards database:', error);
      res.status(500).json({ message: 'Failed to sync with standards database' });
    }
  });

  // Standards Compliance routes
  app.get('/api/standards-compliance', async (req, res) => {
    try {
      const { commodityId, standardId, status } = req.query;
      let compliance;
      
      if (commodityId) {
        compliance = await storage.getStandardsComplianceByCommodity(parseInt(commodityId as string));
      } else if (standardId) {
        compliance = await storage.getStandardsComplianceByStandard(parseInt(standardId as string));
      } else if (status) {
        compliance = await storage.getStandardsComplianceByStatus(status as string);
      } else {
        compliance = await storage.getStandardsCompliance();
      }
      
      res.json(compliance);
    } catch (error) {
      console.error('Error fetching standards compliance:', error);
      res.status(500).json({ message: 'Failed to fetch standards compliance' });
    }
  });

  app.post('/api/standards-compliance', async (req, res) => {
    try {
      const validatedData = insertCommodityStandardsComplianceSchema.parse(req.body);
      const compliance = await storage.createStandardsCompliance(validatedData);
      res.status(201).json(compliance);
    } catch (error) {
      console.error('Error creating standards compliance:', error);
      res.status(500).json({ message: 'Failed to create standards compliance' });
    }
  });

  app.post('/api/commodities/:id/check-standards-compliance', async (req, res) => {
    try {
      const commodityId = parseInt(req.params.id);
      
      // Simulate compliance check process
      const complianceResult = {
        commodityId,
        overallScore: Math.floor(Math.random() * 100) + 1,
        complianceChecks: [
          { standard: 'Fair Trade', status: 'compliant', score: 95 },
          { standard: 'Rainforest Alliance', status: 'pending', score: 0 },
          { standard: 'UTZ', status: 'compliant', score: 88 },
          { standard: 'GlobalGAP', status: 'non_compliant', score: 45 }
        ],
        recommendations: [
          'Complete Rainforest Alliance documentation',
          'Improve GlobalGAP certification requirements'
        ],
        checkDate: new Date()
      };
      
      res.json(complianceResult);
    } catch (error) {
      console.error('Error checking standards compliance:', error);
      res.status(500).json({ message: 'Failed to check standards compliance' });
    }
  });

  // Standards API Integration routes
  app.get('/api/standards-api-integrations', async (req, res) => {
    try {
      const { standardId } = req.query;
      let integrations;
      
      if (standardId) {
        integrations = await storage.getStandardsApiIntegrationByStandard(parseInt(standardId as string));
      } else {
        integrations = await storage.getStandardsApiIntegrations();
      }
      
      res.json(integrations);
    } catch (error) {
      console.error('Error fetching standards API integrations:', error);
      res.status(500).json({ message: 'Failed to fetch standards API integrations' });
    }
  });

  app.post('/api/standards-api-integrations', async (req, res) => {
    try {
      const validatedData = insertStandardsApiIntegrationSchema.parse(req.body);
      const integration = await storage.createStandardsApiIntegration(validatedData);
      res.status(201).json(integration);
    } catch (error) {
      console.error('Error creating standards API integration:', error);
      res.status(500).json({ message: 'Failed to create standards API integration' });
    }
  });

  // Standards Sync Log routes
  app.get('/api/standards-sync-logs', async (req, res) => {
    try {
      const { apiIntegrationId } = req.query;
      let logs;
      
      if (apiIntegrationId) {
        logs = await storage.getStandardsSyncLogsByIntegration(parseInt(apiIntegrationId as string));
      } else {
        logs = await storage.getStandardsSyncLogs();
      }
      
      res.json(logs);
    } catch (error) {
      console.error('Error fetching standards sync logs:', error);
      res.status(500).json({ message: 'Failed to fetch standards sync logs' });
    }
  });

  app.post('/api/standards-sync-logs', async (req, res) => {
    try {
      const validatedData = insertStandardsSyncLogSchema.parse(req.body);
      const log = await storage.createStandardsSyncLog(validatedData);
      res.status(201).json(log);
    } catch (error) {
      console.error('Error creating standards sync log:', error);
      res.status(500).json({ message: 'Failed to create standards sync log' });
    }
  });

  const httpServer = createServer(app);
  return httpServer;
}
